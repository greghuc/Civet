#!/usr/bin/env node
"use strict"
try { require('node:module').enableCompileCache() } catch {}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// unplugin-civet:/Users/greghuc/workspace/Civet/source/cli.civet.jsx
var cli_civet_exports = {};
__export(cli_civet_exports, {
  cli: () => cli,
  parseArgs: () => parseArgs,
  repl: () => repl,
  version: () => version
});
module.exports = __toCommonJS(cli_civet_exports);
var import_main = require("./main.js");
var import_config = require("./config.js");
var import_unplugin = require("./unplugin/unplugin.js");
var import_promises = __toESM(require("node:fs/promises"));
var import_node_path = __toESM(require("node:path"));
var import_meta = {};
var unplugin;
async function version() {
  if (import_meta.url) {
    const { createRequire } = await import("node:module");
    return createRequire(import_meta.url)("../package.json").version;
  } else {
    return require("../package.json").version;
  }
}
var encoding = "utf8";
async function parseArgs(args, isTTY = process.stdin.isTTY) {
  const options = {};
  const isRun = () => !(options.ast || options.compile || options.typecheck || options.emitDeclaration);
  let filenames = [];
  let scriptArgs = [];
  if (args.includes("-version")) {
    options.version = true;
  }
  if (args.includes("-help")) {
    options.help = true;
  }
  if (options.version || options.help) {
    return { filenames, scriptArgs, options };
  }
  let i = 0;
  let errors = 0;
  function endOfArgs(j) {
    i = args.length;
    if (j >= args.length) {
      return;
    }
    if (options.run) {
      filenames.push(args[j]);
      scriptArgs = args.slice(j + 1);
    } else {
      filenames.push(...args.slice(j));
    }
  }
  while (i < args.length) {
    const arg = args[i];
    if (/^-\w{2,}$/.test(arg)) {
      const results = [];
      for (let ref = arg.slice(1), i1 = 0, len = ref.length; i1 < len; i1++) {
        const char = ref[i1];
        results.push(`-${char}`);
      }
      ;
      args.splice(i, i + 1 - i, ...results);
      continue;
    }
    switch (arg) {
      case "-v":
      case "--version": {
        options.version = true;
        break;
      }
      case "-h":
      case "--help": {
        options.help = true;
        break;
      }
      case "-c":
      case "--compile": {
        options.compile = true;
        break;
      }
      case "-o":
      case "--output": {
        options.output = args[++i];
        break;
      }
      case "-e":
      case "--eval": {
        options.eval = args[++i];
        break;
      }
      case "--config": {
        options.config = args[++i];
        break;
      }
      case "--no-config": {
        options.config = false;
        break;
      }
      case "--civet": {
        Object.assign(
          options.parseOptions ??= {},
          (0, import_main.parse)(`civet ${args[++i]}`, {
            startRule: "CivetPrologueContent",
            filename: "--civet argument",
            events: {
              // remove cache in case we've compiled Civet before
              enter: void 0,
              exit: void 0
            }
          }).config
        );
        break;
      }
      case "--comptime": {
        (options.parseOptions ??= {}).comptime = true;
        break;
      }
      case "--no-comptime": {
        (options.parseOptions ??= {}).comptime = false;
        break;
      }
      case "--ast": {
        options.ast = true;
        break;
      }
      case "--no-cache": {
        options.noCache = true;
        break;
      }
      case "--inline-map": {
        options.inlineMap = true;
        break;
      }
      case "--js": {
        options.js = true;
        break;
      }
      case "--hits": {
        options.hits = args[++i];
        break;
      }
      case "--trace": {
        options.trace = args[++i];
        break;
      }
      case "--typecheck": {
        options.typecheck = true;
        break;
      }
      case "--emit-declaration":
      case "--emitDeclaration": {
        options.emitDeclaration = true;
        break;
      }
      case "--": {
        endOfArgs(++i);
        break;
      }
      // remaining arguments are filename and/or arguments
      default: {
        if (arg.startsWith("-") && arg !== "-") {
          console.error(`Invalid command-line argument: ${arg}`);
          errors++;
        } else if (options.run = isRun()) {
          endOfArgs(i);
        } else {
          filenames.push(arg);
        }
      }
    }
    i++;
  }
  if (options.typecheck || options.emitDeclaration) {
    options.typescript = true;
  }
  if (!(filenames.length || options.typescript || options.eval)) {
    if (isTTY) {
      options.repl = true;
    } else {
      options.compile = true;
      options.run = false;
      filenames = ["-"];
    }
  }
  if (options.output && options.output !== "-") {
    const optionsPath = import_node_path.default.parse(options.output);
    let stat;
    try {
      stat = await import_promises.default.stat(options.output);
    } catch {
      stat = null;
    }
    if (stat?.isDirectory() || options.output.endsWith(import_node_path.default.sep) || options.output.endsWith("/")) {
      options.outputDir = options.output;
    } else if (/^(\.[^]+)+$/.test(optionsPath.base)) {
      options.outputExt = optionsPath.base;
      if (optionsPath.dir) {
        options.outputDir = optionsPath.dir;
      }
    } else {
      options.outputPath = optionsPath;
      options.outputExt = optionsPath.ext;
    }
  }
  ;
  (options.parseOptions ??= {}).rewriteCivetImports ??= options.outputExt ?? ".civet.jsx";
  if (errors) {
    process.exit(Math.min(255, errors));
  }
  options.run = isRun();
  return { filenames, scriptArgs, options };
}
async function* readFiles(filenames, evalString) {
  if (evalString != null) {
    yield {
      filename: "<eval>",
      content: evalString + "\n",
      stdin: true
    };
  }
  for (let i2 = 0, len1 = filenames.length; i2 < len1; i2++) {
    let filename = filenames[i2];
    const stdin = filename === "-";
    try {
      let content;
      if (stdin) {
        process.stdin.setEncoding(encoding);
        filename = "<stdin>";
        try {
          filename = await import_promises.default.realpath("/dev/stdin");
        } catch (e) {
        }
        if (process.stdin.isTTY) {
          const lines = [];
          const rl = (await import("node:readline")).createInterface(process.stdin, process.stdout);
          rl.on("line", (buffer) => lines.push(buffer + "\n"));
          content = await new Promise((resolve, reject) => {
            rl.on("SIGINT", () => {
              return reject("^C");
            });
            return rl.on("close", () => {
              return resolve(lines.join(""));
            });
          });
        } else {
          content = (await (async () => {
            const results1 = [];
            for await (const chunk of process.stdin) {
              results1.push(chunk);
            }
            return results1;
          })()).join("");
        }
      } else {
        content = await import_promises.default.readFile(filename, { encoding });
      }
      yield { filename, content, stdin };
    } catch (error) {
      yield { filename, error, stdin };
    }
  }
}
async function repl(args, options) {
  const vm = await import("node:vm");
  let importModuleDynamically = vm.constants?.USE_MAIN_CONTEXT_DEFAULT_LOADER;
  if (!importModuleDynamically) {
    if (vm.SourceTextModule != null) {
      const { pathToFileURL } = await import("node:url");
      importModuleDynamically = (specifier) => {
        if (/^\.\.?[/\\]/.test(specifier)) {
          return import(pathToFileURL(import_node_path.default.join(process.cwd(), specifier)).href);
        } else {
          return import(specifier);
        }
      };
    } else {
      const execArgv = ["--experimental-vm-modules"];
      const { fork } = await import("node:child_process");
      fork(__filename, args, {
        execArgv,
        stdio: "inherit"
      });
      return;
    }
  }
  await import("../register.js");
  console.log(`Civet ${await version()} REPL.  Enter a blank line to ${(() => {
    switch (false) {
      case !options.ast: {
        return "parse";
      }
      case !options.compile: {
        return "transpile";
      }
      default: {
        return "execute";
      }
    }
  })()} code.`);
  global.quit = global.exit = () => process.exit(0);
  const nodeRepl = await import("node:repl");
  const r = nodeRepl.start({
    prompt: (() => {
      switch (false) {
        case !options.ast: {
          return "\u{1F332}> ";
        }
        case !options.compile: {
          return "\u{1F408}> ";
        }
        default: {
          return "\u{1F431}> ";
        }
      }
    })(),
    writer: (() => {
      if (options.ast) {
        return (obj) => {
          try {
            return JSON.stringify(obj, null, 2);
          } catch (e) {
            console.log(`Failed to stringify: ${e}`);
            return "";
          }
        };
      } else if (options.compile) {
        return (obj) => {
          if (typeof obj === "string") {
            return obj?.replace(/\n*$/, "");
          } else {
            return "";
          }
        };
      }
      ;
      return;
    })(),
    eval: async function(input, context, filename, callback) {
      input = input.replace(/\r/g, "\n");
      if (input === "\n") {
        return callback(null, void 0);
      } else if (input in ["quit\n", "exit\n", "quit()\n", "exit()\n"]) {
        return process.exit(0);
      } else if (input.endsWith("\n\n")) {
        let showError = function(error) {
          console.error("Error while parsing Civet code:");
          if ((0, import_main.isCompileError)(error)) {
            if (error.errors != null) {
              error = error.errors[0];
            }
            return console.log(`${input.split("\n").slice(0, error.line).join("\n")}
${" ".repeat(error.column - 1)}^ ${error.header}`);
          } else {
            return console.error(error);
          }
        };
        let output;
        if (options.compile || options.ast) {
          try {
            output = await (0, import_main.compile)(input, { ...options, filename });
          } catch (error) {
            showError(error);
            return callback(null, void 0);
          }
          return callback(null, output);
        }
        const parseOptions = {
          ...options.parseOptions,
          repl: true
        };
        let ast;
        try {
          ast = await (0, import_main.compile)(input, { ...options, parseOptions, filename, ast: true });
        } catch (error) {
          showError(error);
          return callback(null, void 0);
        }
        let errors = [];
        try {
          output = (0, import_main.generate)(ast, { ...options, errors, sourceMap: void 0 });
        } catch (error) {
          console.error(error);
          return callback(null, void 0);
        }
        if (errors.length) {
          errors = [];
          (0, import_main.generate)(ast, { ...options, errors, sourceMap: new import_main.SourceMap(input) });
          showError(errors[0]);
          return callback(null, void 0);
        }
        let result;
        try {
          result = vm.runInContext(output, context, {
            filename,
            importModuleDynamically
          });
        } catch (error) {
          return callback(error, void 0);
        }
        if (ast.topLevelAwait) {
          let ok = true;
          try {
            return result = await result;
          } catch (error) {
            ok = false;
            return callback(error, void 0);
          } finally {
            if (ok) {
              callback(null, result);
            }
          }
        } else {
          return callback(null, result);
        }
      } else {
        return callback(new nodeRepl.Recoverable(new Error("Enter a blank line to execute code.")), null);
      }
    }
  });
  return r;
}
async function cli(args = process.argv.slice(2)) {
  let { filenames, scriptArgs, options } = await parseArgs(args);
  if (options.version) {
    console.log(await version());
    process.exit(0);
  }
  if (options.help) {
    process.stderr.write(`       \u2584\u2584\xB7 \u25AA   \u258C \u2590\xB7\u2584\u2584\u2584 .\u2584\u2584\u2584\u2584\u2584
      \u2590\u2588 \u258C\u25AA\u2588\u2588 \u25AA\u2588\xB7\u2588\u258C\u2580\u2584.\u2580\xB7\u2022\u2588\u2588       _._     _,-'""\`-._
      \u2588\u2588 \u2584\u2584\u2590\u2588\xB7\u2590\u2588\u2590\u2588\u2022\u2590\u2580\u2580\u25AA\u2584 \u2590\u2588.\u25AA    (,-.\`._,'(       |\\\`-/|
      \u2590\u2588\u2588\u2588\u258C\u2590\u2588\u258C \u2588\u2588\u2588 \u2590\u2588\u2584\u2584\u258C \u2590\u2588\u258C\xB7        \`-.-' \\ )-\`( , o o)
      \xB7\u2580\u2580\u2580 \u2580\u2580\u2580. \u2580   \u2580\u2580\u2580  \u2580\u2580\u2580               \`-    \\\`_\`"'-


Usage:

    civet                                        # REPL for executing code
    civet -c                                     # REPL for transpiling code
    civet --ast                                  # REPL for parsing code
    civet [options] input.civet                  # run input.civet
    civet [options] -c input.civet               # -> input.civet.tsx
    civet [options] -c input.civet -o .ts        # -> input.ts
    civet [options] -c input.civet -o dir        # -> dir/input.civet.tsx
    civet [options] -c input.civet -o dir/.ts    # -> dir/input.ts
    civet [options] -c input.civet -o output.ts  # -> output.ts
    civet [options] < input.civet > output.ts    # pipe form

Options:
  --help           Show this help message
  --version        Show the version number
  -o / --output XX Specify output directory and/or extension, or filename
  -c / --compile   Compile input files to TypeScript (or JavaScript)
  -e / --eval XX   Evaluate specified code (or compile it with -c)
  --config XX      Specify a config file (default scans for a config.civet, civet.json, civetconfig.civet or civetconfig.json file, optionally in a .config directory, or starting with a .)
  --civet XX       Specify civet compiler flag, as in "civet XX" prologue
  --comptime       Enable execution of code during compilation via comptime
  --no-config      Don't scan for a config file
  --js             Strip out all type annotations; default to .jsx extension
  --ast            Print the AST instead of the compiled code
  --inline-map     Generate a sourcemap
  --no-cache       Disable compiler caching (slow, for debugging)
  --typecheck      Run TypeScript and output diagnostics
  --emit-declaration  Run TypeScript and emit .d.ts files (if no errors)
  --trace XX       Log detailed parsing notes to a file, for parser debugging

You can use - to read from stdin or (prefixed by -o) write to stdout.

By default, .civet imports get rewritten to use the output extension.
You can override this behavior via: --civet rewriteCivetImports=.ext

`);
    process.exit(0);
  }
  if (options.config === void 0) {
    options.config = await (0, import_config.findConfig)(process.cwd());
  }
  if (options.config) {
    const parsed = await (0, import_config.loadConfig)(options.config);
    options = {
      ...parsed,
      ...options
    };
    if (parsed.parseOptions && options.parseOptions) {
      options.parseOptions = {
        ...parsed.parseOptions,
        ...options.parseOptions
      };
    }
  }
  if (options.typescript) {
    const unpluginOptions = {
      ...options,
      ts: options.js ? "civet" : "preserve",
      outputExtension: ".tsx",
      declarationExtension: options.outputExt?.replace(/\.[jt]sx?$/i, ".d.ts")
    };
    (unpluginOptions.parseOptions ??= {}).rewriteCivetImports = ".civet.jsx";
    unplugin = (0, import_unplugin.rawPlugin)(unpluginOptions, { framework: "civet-cli" });
    await unplugin.buildStart();
  }
  if (options.run) {
    options.js = true;
    options.inlineMap = true;
  }
  if (options.repl) {
    return repl(args, options);
  }
  process.stdout.on("error", (e) => {
    if (["EPIPE", "EOF"].includes(e.code)) {
      return process.exit(0);
    } else {
      console.error(e);
      return process.exit(1);
    }
  });
  let errors = 0;
  for await (let { filename, error, content, stdin } of readFiles(filenames, options.eval)) {
    if (error) {
      console.error(`${filename} failed to load:`);
      console.error(error);
      errors++;
      continue;
    }
    let output;
    try {
      if (unplugin != null) {
        output = (await unplugin.load.call({
          addWatchFile() {
            ;
          }
        }, `${filename}.tsx`)).code;
      } else {
        output = await (0, import_main.compile)(content, { ...options, filename });
      }
    } catch (error2) {
      console.error(error2);
      errors++;
      continue;
    }
    if (options.ast) {
      process.stdout.write(JSON.stringify(output, null, 2));
    } else if (options.compile) {
      if (stdin && !options.output || options.output === "-") {
        process.stdout.write(output);
      } else {
        let targetPath = import_node_path.default.parse(filename);
        delete targetPath.base;
        if (options.js) {
          targetPath.ext += ".jsx";
        } else {
          targetPath.ext += ".tsx";
        }
        if (options.outputDir != null) {
          targetPath.dir = options.outputDir;
        }
        if (options.outputExt != null) {
          targetPath.ext = options.outputExt;
        }
        if (options.outputPath != null) {
          targetPath = options.outputPath;
        }
        if (targetPath.dir) {
          await import_promises.default.mkdir(targetPath.dir, { recursive: true });
        }
        const targetFilename = import_node_path.default.format(targetPath);
        try {
          await import_promises.default.writeFile(targetFilename, output);
        } catch (error2) {
          console.error(`${targetFilename} failed to write:`);
          console.error(error2);
          errors++;
        }
      }
    } else if (options.run) {
      let ref1;
      {
        if (typeof output === "string" && /\b(await|import|export)\b/.test(output)) {
          const ast = await (0, import_main.compile)(content, { ...options, ast: true, filename });
          ref1 = import_main.lib.hasAwait(ast) || import_main.lib.hasImportDeclaration(ast) || import_main.lib.hasExportDeclaration(ast);
        } else {
          ref1 = void 0;
        }
      }
      ;
      const esm = ref1;
      if (esm) {
        if (stdin) {
          filename = `.stdin-${process.pid}.civet`;
          try {
            await import_promises.default.writeFile(filename, content, { encoding });
          } catch (e) {
            console.error(`Could not write ${filename} for Civet ESM mode:`);
            console.error(e);
            process.exit(1);
          }
        }
        const { fork } = await import("node:child_process");
        const { register } = await import("node:module");
        let execArgv;
        if (register) {
          const { join } = await import("path");
          const { pathToFileURL } = await import("node:url");
          execArgv = [
            "--import",
            pathToFileURL(join(__dirname, "../register.js")).href
          ];
        } else {
          execArgv = [
            "--loader",
            "@danielx/civet/esm",
            // ESM
            "--require",
            "@danielx/civet/register"
            // CJS
          ];
        }
        const debugRe = /--debug|--inspect/;
        const isDebug = typeof v8debug === "object" || debugRe.test(process.execArgv.join(" ")) || debugRe.test(process.env.NODE_OPTIONS ?? "");
        if (isDebug) {
          execArgv.push("--inspect=" + (process.debugPort + 1));
        }
        const child = fork(filename, [
          ...scriptArgs
        ], {
          execArgv,
          stdio: "inherit"
        });
        child.on("exit", async (code) => {
          if (stdin) {
            await import_promises.default.unlink(filename);
          }
          return process.exit(code ?? 1);
        });
      } else {
        await import("../register.js");
        try {
          module.filename = await import_promises.default.realpath(filename);
        } catch {
          module.filename = filename;
        }
        process.argv = ["civet", module.filename, ...scriptArgs];
        module.paths = (await import("node:module"))._nodeModulePaths(import_node_path.default.dirname(module.filename));
        try {
          module._compile(output, module.filename);
        } catch (error2) {
          console.error(`${filename} crashed while running in CJS mode:`);
          console.error(error2);
          process.exit(1);
        }
      }
    }
  }
  process.exitCode = Math.min(255, errors);
  if (unplugin != null) {
    try {
      return await unplugin.buildEnd.call({
        emitFile({ source, fileName }) {
          return import_promises.default.writeFile(fileName, source);
        }
      }, !filenames.length);
    } catch (error) {
      let ref2;
      if (ref2 = error.message.match(/Aborting build because of (\d+) TypeScript diagnostic/)) {
        const match = ref2;
        return process.exitCode = Math.min(255, errors + +match[1]);
      } else {
        process.exitCode = 1;
        throw error;
      }
    }
  }
  ;
  return;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cli,
  parseArgs,
  repl,
  version
});
cli()
